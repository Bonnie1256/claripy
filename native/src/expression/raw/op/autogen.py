'''@file
@brief This file is used to autogenerate op subclasses
This file *will* overwrite existing files

Within the defined io directory there must exist a config json file.
The config file will contain a list of dicts, each containing three things:
{
    'file' : <file_path>,
    'op' : <op name>,
    'args' : <a list of unnamed argument types>
}
These entries will be used to autogenerate, in the autogen_dir,
a set of files that contain the necessary subclasses of op,
along with shared pointer aliases to each as needed.

Additionally generates autogen.hpp in io_dir

Finally prints out a relative path to each new source to sources_out in io_dir
'''

import argparse
import json
import sys
import os


# Constants
io_dir = os.path.realpath('op')
autogen_dir_name = 'autogen'
namespace = 'Expresson::Raw'
autogen_dir = os.path.join(io_dir, autogen_dir_name)
config_f = os.path.join(io_dir, 'autogen.json')
autogenhpp = os.path.join(io_dir, 'autogen.hpp')
sources_out = os.path.join(io_dir, 'sources.txt')
header_guard_prefix = '__EXPRESSION_RAW_'


# Helper functions


def header_guard_top(fname):
    fname = fname.split('.')[0]
    return header_guard_prefix + fname.upper() + '_HPP__'

def header_guard_autogen(fname):
    fname = fname.split('.')[0]
    return header_guard_prefix + autogen_dir_name.upper() + '_' + fname.upper() + '_HPP__'

def create_header_guard(header_guard):
    return '#ifndef ' + header_guard + '\n#define ' + header_guard + '\n'


# Generation functions


def generate_header(file, op, args):
    output_fname = os.path.join(output_dir, file, header_files)
    header_files.append(output_fname)
    # Construct prefix and suffix
    doxygen = '/**\n * @file\n * @brief This file defines relevant subclasses of ' + op
    doxygen += '\nThis file was autogenerated by autogen.py'
    includes = '#include "' + os.path.relpath(output_fname, os.path.join(io_dir, file)) + '"'
    prefix = '\n\n'.join([doxygen, create_header_guard(header_guard_autogen(file)), includes])
    suffix = '#endif'
    # Create body

    # TODO: also have to handle op namespace etc

    # Write out
    output = '\n\n'.join([prefix, mid, suffix])
    with open(output_fname, 'w') as f:
        f.write(output)

def generate_source(file, op, args, source_files):
    file = file[:-4] + '.cpp'
    source_files.append(file)
    # Create prefix
    output_fname = os.path.join(output_dir, file)
    prefix = '/** @file */\n#include "' + file '"'

    # TODO:

    # Write out
    output = prefix + '\n\n' + body
    with open(output_fname, 'w') as f:
        f.write(output)

def generate_autogen(files):
    doxygen = '/**\n * @file\n * @brief This file includes all headers used by autogen.py'
    doxygen += '\nThis file was autogenerated by autogen.py'
    prefix = doxygen + '\n\n' + create_header_guard(header_guard_top(autogenhpp)) + '\n'
    mid = '\n'.join([ '#include "' + i + '"' for i in files ])
    suffix = '\n\n#endif'
    # Write out to file
    output = prefix + mid + suffix
    with open(autogenhpp, 'w') as f:
        f.write(output)

def generate_sources_out(files):
    prefix = os.path.relpath(autogen_dir, io_dir)
    output = '\n'.join([os.path.join(prefix, i) for i in files])
    with open(sources_out, 'w') as f:
        f.write(output)

# Other functions


def verify_config(config):
    assert(type(config) == list, 'Config must have a list type')
    # Entry verification
    for entry in config:
        assert(type(entry) == dict, 'Config entry of improper type')
        assert(set(entry.keys()) == ['file', 'op', 'args'], 'Config entry has improper keys')
        # File verification
        assert(type(config['file']) == str, 'Config entry["file"] should be of type str')
        assert(config['file'].endswith('.hpp'), 'Config entry["file"] must be an hpp file')
        assert(os.path.basename(config['file']) == config['file']),
            'Config entry["file"] must be the file basename')
        assert(os.path.exists(os.path.exists(os.path.join(input_dir, config['file'])),
            'Config entry["file"] does not exist');
        # Op verification
        assert(type(config['op']) == str, 'Config entry["op"] should be of type str')
        # Args verification
        assert(type(config['args']) == list, 'Config entry["file"] should be of type list')
        for i in config['args']:
            assert(type(i) == str, 'Config entry["file"] entry should be of type str')

def main():
    # Error checking
    assert(os.path.exists(input_dir), 'Bad input_dir')
    assert(os.path.exists(output_dir), 'Bad output_dir')
    assert(os.path.exists(config_f), 'Missing config file')
    # Verify config file
    with open(config_f) as f:
        config = f.read()
    config = json.loads(config)
    verify_config(config)
    # Init
    source_files = []
    header_files = []
    # Generate each file
    for entry in config:
        generate_header(**entry, header_files)
        generate_source(**entry, source_files)
    # Generate op.hpp
    generate_autogen(header_files)
    generate_sources_out(source_files)


# Don't run on import
if __name__ == '__main__':
    main()
